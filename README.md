## Порівняння алгоритмів сторвування

| Algorithm      | Small   | Medium  | Large   |
| -------------- | ------- | ------- | ------- |
| Insertion Sort | 0.00045 | 0.07989 | 6.26548 |
| Merge Sort     | 0.00036 | 0.00500 | 0.06011 |
| Timsort        | 0.00002 | 0.00030 | 0.00331 |

За поданими даними ми можемо зробити деякі спостереження:

1. **Insertion Sort**:

   - На великих масивах (Large) Insertion Sort показує значно гіршу продуктивність порівняно з Merge Sort і Timsort. Це відповідає теоретичним очікуванням, оскільки часова складність Insertion Sort у найгіршому випадку становить O(n^2), що робить його менш ефективним для великих масивів.
   - На середніх масивах (Medium) також помітна велика різниця у продуктивності між Insertion Sort і двома іншими алгоритмами. Це також відповідає теоретичним очікуванням, оскільки часова складність Insertion Sort у середньому випадку також становить O(n^2), хоча менш значна.
   - На малих масивах (Small) Insertion Sort показує прийнятну продуктивність, що відображає його властивість бути ефективним для невеликих масивів.

2. **Merge Sort**:

   - Merge Sort продемонстрував стабільну продуктивність на всіх розмірах масивів. Його час виконання зростає лінійно з розміром масиву, що відповідає його теоретичній часовій складності O(n log n).
   - Merge Sort показав гарну продуктивність навіть на великих масивах, що робить його ефективним алгоритмом сортування для різних розмірів вхідних даних.

3. **Timsort**:
   - Timsort показав найкращі результати на всіх розмірах масивів. Це підтверджує його популярність і широке використання в реальних застосунках, оскільки він є оптимізованим для роботи з різними типами даних та різними розмірами масивів.

Отже, емпіричні дані відображають теоретичні очікування щодо продуктивності цих алгоритмів на великих масивах, демонструючи переваги Merge Sort і Timsort над Insertion Sort.
